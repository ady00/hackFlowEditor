{
  "version": 3,
  "sources": ["../@babel/runtime/helpers/esm/extends.js", "../@radix-ui/react-id/dist/packages/react/id/src/id.tsx", "../@radix-ui/react-use-callback-ref/dist/packages/react/use-callback-ref/src/useCallbackRef.tsx", "../@radix-ui/react-use-controllable-state/dist/packages/react/use-controllable-state/src/useControllableState.tsx", "../@radix-ui/react-primitive/dist/packages/react/primitive/src/Primitive.tsx", "../@radix-ui/react-primitive/dist/packages/react/primitive/src/extendPrimitive.tsx", "../@radix-ui/react-context/dist/packages/react/context/src/createContext.tsx", "../@radix-ui/react-compose-refs/dist/packages/react/compose-refs/src/composeRefs.tsx", "../@radix-ui/react-slot/dist/packages/react/slot/src/Slot.tsx", "../@radix-ui/react-collection/dist/packages/react/collection/src/Collection.tsx", "../@radix-ui/primitive/dist/packages/core/primitive/src/primitive.tsx", "../@radix-ui/react-roving-focus/dist/packages/react/roving-focus/src/RovingFocusGroup.tsx", "../@radix-ui/react-tabs/dist/packages/react/tabs/src/Tabs.tsx"],
  "sourcesContent": ["export default function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}", "// This implementation is heavily inspired by react-aria's implementation\n// See: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/ssr/src/SSRProvider.tsx\n\nimport * as React from 'react';\n\ntype IdContextValue = {\n  prefix: number;\n  current: number;\n};\n\nconst defaultIdContext: IdContextValue = {\n  prefix: Math.round(Math.random() * 10000000000),\n  current: 0,\n};\n\nconst IdContext = React.createContext<IdContextValue>(defaultIdContext);\n\nconst IdProvider: React.FC = (props) => {\n  const currentContext = React.useContext(IdContext);\n  const isRootIdProvider = currentContext === defaultIdContext;\n  const context: IdContextValue = React.useMemo(\n    () => ({\n      prefix: isRootIdProvider ? 0 : ++currentContext.prefix,\n      current: 0,\n    }),\n    [isRootIdProvider, currentContext]\n  );\n\n  return <IdContext.Provider value={context} {...props} />;\n};\n\nfunction useId(deterministicId?: string): string {\n  const context = React.useContext(IdContext);\n  const isBrowser = Boolean(globalThis?.document);\n\n  if (!isBrowser && context === defaultIdContext) {\n    console.warn(\n      'When server rendering, you must wrap your application in an <IdProvider> to ensure consistent ids are generated between the client and server.'\n    );\n  }\n\n  return React.useMemo(\n    () => deterministicId || `radix-id-${context.prefix}-${++context.current}`,\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [deterministicId]\n  );\n}\n\nexport { IdProvider, useId };\n", "import * as React from 'react';\n\n/**\n * A custom hook that converts a callback to a ref to avoid triggering re-renders when passed as a\n * prop or avoid re-executing effects when passed as a dependency\n */\nfunction useCallbackRef<T extends (...args: any[]) => any>(callback: T | undefined): T {\n  const callbackRef = React.useRef(callback);\n\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n\n  return React.useCallback(\n    ((...args) => {\n      return callbackRef.current?.(...args);\n    }) as T,\n    []\n  );\n}\n\nexport { useCallbackRef };\n", "import * as React from 'react';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\ntype UseControllableStateParams<T> = {\n  prop?: T | undefined;\n  defaultProp?: T | undefined;\n  onChange?: (state: T) => void;\n};\n\ntype SetStateFn<T> = (prevState?: T) => T;\n\nfunction useControllableState<T>({\n  prop,\n  defaultProp,\n  onChange = () => {},\n}: UseControllableStateParams<T>) {\n  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });\n  const isControlled = prop !== undefined;\n  const value = isControlled ? prop : uncontrolledProp;\n  const handleChange = useCallbackRef(onChange);\n\n  const setValue: React.Dispatch<React.SetStateAction<T | undefined>> = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const setter = nextValue as SetStateFn<T>;\n        const value = typeof nextValue === 'function' ? setter(prop) : nextValue;\n        if (value !== prop) handleChange(value as T);\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, handleChange]\n  );\n\n  return [value, setValue] as const;\n}\n\nfunction useUncontrolledState<T>({\n  defaultProp,\n  onChange,\n}: Omit<UseControllableStateParams<T>, 'prop'>) {\n  const uncontrolledState = React.useState<T | undefined>(defaultProp);\n  const [value] = uncontrolledState;\n  const prevValueRef = React.useRef(value);\n  const handleChange = useCallbackRef(onChange);\n\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      handleChange(value as T);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef, handleChange]);\n\n  return uncontrolledState;\n}\n\nexport { useControllableState };\n", "import * as React from 'react';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n/* -------------------------------------------------------------------------------------------------\n * Primitive\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAME = 'Primitive';\nconst DEFAULT_TAG = 'div';\n\ntype PrimitiveOwnProps = {};\ntype PrimitivePrimitive = Polymorphic.ForwardRefComponent<typeof DEFAULT_TAG, PrimitiveOwnProps>;\n\nconst Primitive = React.forwardRef((props, forwardedRef) => {\n  const { as: Comp = DEFAULT_TAG, ...primitiveProps } = props;\n  return <Comp {...primitiveProps} ref={forwardedRef} />;\n}) as PrimitivePrimitive;\n\nPrimitive.displayName = NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Primitive;\n\nexport {\n  Primitive,\n  //\n  Root,\n};\nexport type { PrimitivePrimitive };\n", "import * as React from 'react';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\ntype ExtendedPrimitive<C, As> = Polymorphic.ForwardRefComponent<As, Polymorphic.OwnProps<C>>;\ntype DefaultProps<C, As> = { as?: As } & Omit<\n  Partial<React.ComponentProps<ExtendedPrimitive<C, As>>>,\n  'as'\n>;\n\nfunction extendPrimitive<\n  C extends Polymorphic.ForwardRefComponent<any, any>,\n  DefaultAs extends React.ElementType = Polymorphic.IntrinsicElement<C>\n>(Comp: C, config: { displayName?: string; defaultProps?: DefaultProps<C, DefaultAs> }) {\n  const Extended = React.forwardRef((props, forwardedRef) => {\n    const As = Comp as any;\n    const propsWithDefaults = { ...config.defaultProps, ...props };\n    return <As {...propsWithDefaults} ref={forwardedRef} />;\n  });\n\n  Extended.displayName = config.displayName || 'Extended' + Comp.displayName;\n  return Extended as ExtendedPrimitive<C, DefaultAs>;\n}\n\nexport { extendPrimitive };\nexport type { ExtendedPrimitive };\n", "import * as React from 'react';\n\nfunction createContext<ContextValueType extends object>(rootComponentName: string) {\n  const Context = React.createContext<ContextValueType>(null as any);\n\n  function Provider(props: ContextValueType & { children: React.ReactNode }) {\n    const { children, ...providerProps } = props;\n    // Only re-memoize when prop values change\n    const value = React.useMemo(\n      () => providerProps,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      Object.values(providerProps)\n    ) as ContextValueType;\n    return <Context.Provider value={value}>{children}</Context.Provider>;\n  }\n\n  function useContext(consumerName: string) {\n    const context = React.useContext(Context);\n    if (context === null) {\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    return context;\n  }\n\n  Provider.displayName = rootComponentName + 'Provider';\n  return [Provider, useContext] as const;\n}\n\nexport { createContext };\n", "import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    (ref as React.MutableRefObject<T>).current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]) {\n  return (node: T) => refs.forEach((ref) => setRef(ref, node));\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n", "import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ntype SlotProps = { children?: React.ReactNode };\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childLength = React.Children.count(children);\n\n  if (childLength === 1) {\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {children}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <>\n      {React.Children.map(children, (child) => {\n        if (React.isValidElement(child) && child.type === Slottable) {\n          return (\n            <SlotClone {...slotProps} ref={forwardedRef}>\n              {child.props.children}\n            </SlotClone>\n          );\n        }\n\n        return child;\n      })}\n    </>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ntype SlotCloneProps = { children: React.ReactNode };\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const child = React.Children.only(children);\n\n  return React.isValidElement(child)\n    ? React.cloneElement(child, {\n        ...mergeProps(slotProps, child.props),\n        ref: composeRefs(forwardedRef, (child as any).ref),\n      })\n    : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return children as React.ReactElement;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    // if it's a handler, modify the override by composing the base handler\n    if (isHandler) {\n      overrideProps[propName] = composeHandlers(childPropValue, slotPropValue);\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\ntype EventHandler = (...args: unknown[]) => unknown;\n\nfunction composeHandlers(childHandler?: EventHandler, slotHandler?: EventHandler) {\n  return function handleEvent(...args) {\n    childHandler?.(...args);\n    const isDefaultPreventedEvent = args[0] instanceof Event && args[0].defaultPrevented;\n    if (!isDefaultPreventedEvent) {\n      slotHandler?.(...args);\n    }\n  } as EventHandler;\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\n", "import React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>\u2026</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData>() {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  type CollectionElement = HTMLElement;\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n  const Context = React.createContext<ContextValue>({} as any);\n\n  const PROVIDER_NAME = 'CollectionProvider';\n\n  const CollectionProvider: React.FC = (props) => {\n    const { children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <Context.Provider value={React.useMemo(() => ({ itemMap, collectionRef: ref }), [itemMap])}>\n        {children}\n      </Context.Provider>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = 'CollectionSlot';\n\n  type SlotProps = React.ComponentProps<typeof Slot>;\n\n  const CollectionSlot = React.forwardRef<CollectionElement, SlotProps>((props, forwardedRef) => {\n    const { children } = props;\n    const context = React.useContext(Context);\n    const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n    return <Slot ref={composedRefs}>{children}</Slot>;\n  });\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = { children: React.ReactNode } & ItemData;\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = React.useContext(Context);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...((itemData as unknown) as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection() {\n    const context = React.useContext(Context);\n    return {\n      getItems() {\n        const orderedNodes = Array.from(\n          context.collectionRef.current!.querySelectorAll(`[${ITEM_DATA_ATTR}]`)\n        );\n        const items = Array.from(context.itemMap.values());\n        const orderedItems = items.sort(\n          (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n        );\n        return orderedItems;\n      },\n    };\n  }\n\n  return [CollectionProvider, CollectionSlot, CollectionItemSlot, useCollection] as const;\n}\n\nexport { createCollection };\n", "function composeEventHandlers<E>(\n  originalEventHandler?: (event: E) => void,\n  ourEventHandler?: (event: E) => void,\n  { checkForDefaultPrevented = true } = {}\n) {\n  return function handleEvent(event: E) {\n    originalEventHandler?.(event);\n\n    if (checkForDefaultPrevented === false || !((event as unknown) as Event).defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\n\nexport { composeEventHandlers };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContext } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [CollectionProvider, CollectionSlot, CollectionItemSlot, useCollection] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>();\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\nconst GROUP_DEFAULT_TAG = 'span';\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ntype RovingFocusGroupOptions = {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n};\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] = createContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupOwnProps = Polymorphic.OwnProps<typeof RovingFocusGroupImpl>;\n\ntype RovingFocusGroupPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof RovingFocusGroupImpl>,\n  RovingFocusGroupOwnProps\n>;\n\nconst RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return (\n    <CollectionProvider>\n      <CollectionSlot>\n        <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n      </CollectionSlot>\n    </CollectionProvider>\n  );\n}) as RovingFocusGroupPrimitive;\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\ntype RovingFocusGroupImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  RovingFocusGroupOptions & {\n    currentTabStopId?: string | null;\n    defaultCurrentTabStopId?: string;\n    onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n    onEntryFocus?: (event: Event) => void;\n  }\n>;\n\ntype RovingFocusGroupImplPrimitive = Polymorphic.ForwardRefComponent<\n  typeof GROUP_DEFAULT_TAG,\n  RovingFocusGroupImplOwnProps\n>;\n\nconst RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    as = GROUP_DEFAULT_TAG,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<React.ElementRef<typeof RovingFocusGroup>>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const { getItems } = useCollection();\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback((tabStopId) => setCurrentTabStopId(tabStopId), [\n        setCurrentTabStopId,\n      ])}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        aria-orientation={orientation}\n        data-orientation={orientation}\n        {...groupProps}\n        as={as}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n}) as RovingFocusGroupImplPrimitive;\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusItem';\nconst ITEM_DEFAULT_TAG = 'span';\n\ntype RovingFocusItemOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    focusable?: boolean;\n    active?: boolean;\n  }\n>;\n\ntype RovingFocusItemPrimitive = Polymorphic.ForwardRefComponent<\n  typeof ITEM_DEFAULT_TAG,\n  RovingFocusItemOwnProps\n>;\n\nconst RovingFocusItem = React.forwardRef((props, forwardedRef) => {\n  const { as = ITEM_DEFAULT_TAG, focusable = true, active = false, ...itemProps } = props;\n  const id = useId();\n  const context = useRovingFocusContext(ITEM_NAME);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const { getItems } = useCollection();\n\n  return (\n    <CollectionItemSlot id={id} focusable={focusable} active={active}>\n      <Primitive\n        tabIndex={isCurrentTabStop ? 0 : -1}\n        data-orientation={context.orientation}\n        {...itemProps}\n        as={as}\n        ref={forwardedRef}\n        onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n          // We prevent focusing non-focusable items on `mousedown`.\n          // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n          if (!focusable) event.preventDefault();\n          // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n          else context.onItemFocus(id);\n        })}\n        onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Tab' && event.shiftKey) {\n            context.onItemShiftTab();\n            return;\n          }\n\n          if (event.target !== event.currentTarget) return;\n\n          const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n          if (focusIntent !== undefined) {\n            event.preventDefault();\n            const items = getItems().filter((item) => item.focusable);\n            let candidateNodes = items.map((item) => item.ref.current!);\n\n            if (focusIntent === 'last') candidateNodes.reverse();\n            else if (focusIntent === 'prev' || focusIntent === 'next') {\n              if (focusIntent === 'prev') candidateNodes.reverse();\n              const currentIndex = candidateNodes.indexOf(event.currentTarget);\n              candidateNodes = context.loop\n                ? wrapArray(candidateNodes, currentIndex + 1)\n                : candidateNodes.slice(currentIndex + 1);\n            }\n\n            /**\n             * Imperative focus during keydown is risky so we prevent React's batching updates\n             * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n             */\n            setTimeout(() => focusFirst(candidateNodes));\n          }\n        })}\n      />\n    </CollectionItemSlot>\n  );\n}) as RovingFocusItemPrimitive;\n\nRovingFocusItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusItem;\n\nexport {\n  RovingFocusGroup,\n  RovingFocusItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupPrimitive, RovingFocusItemPrimitive };\n", "import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createContext } from '@radix-ui/react-context';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { RovingFocusGroup, RovingFocusItem } from '@radix-ui/react-roving-focus';\nimport { useId } from '@radix-ui/react-id';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\ntype RovingFocusGroupProps = React.ComponentProps<typeof RovingFocusGroup>;\n\n/* -------------------------------------------------------------------------------------------------\n * Tabs\n * -----------------------------------------------------------------------------------------------*/\n\nconst TABS_NAME = 'Tabs';\n\ntype TabsContextValue = {\n  baseId: string;\n  value?: string;\n  onValueChange: (value: string) => void;\n  orientation?: TabsOwnProps['orientation'];\n  dir?: TabsOwnProps['dir'];\n  activationMode?: TabsOwnProps['activationMode'];\n};\n\nconst [TabsProvider, useTabsContext] = createContext<TabsContextValue>(TABS_NAME);\n\ntype TabsOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    /** The value for the selected tab, if controlled */\n    value?: string;\n    /** The value of the tab to select by default, if uncontrolled */\n    defaultValue?: string;\n    /** A function called when a new tab is selected */\n    onValueChange?: (value: string) => void;\n    /**\n     * The orientation the tabs are layed out.\n     * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n     * @defaultValue horizontal\n     */\n    orientation?: RovingFocusGroupProps['orientation'];\n    /**\n     * The direction of navigation between toolbar items.\n     * @defaultValue ltr\n     */\n    dir?: RovingFocusGroupProps['dir'];\n    /** Whether a tab is activated automatically or manually (default: automatic) */\n    activationMode?: 'automatic' | 'manual';\n  }\n>;\n\ntype TabsPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof Primitive>,\n  TabsOwnProps\n>;\n\nconst Tabs = React.forwardRef((props, forwardedRef) => {\n  const {\n    value: valueProp,\n    onValueChange,\n    defaultValue,\n    orientation = 'horizontal',\n    dir = 'ltr',\n    activationMode = 'automatic',\n    ...tabsProps\n  } = props;\n\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    onChange: onValueChange,\n    defaultProp: defaultValue,\n  });\n\n  return (\n    <TabsProvider\n      baseId={useId()}\n      value={value}\n      onValueChange={setValue}\n      orientation={orientation}\n      dir={dir}\n      activationMode={activationMode}\n    >\n      <Primitive data-orientation={orientation} {...tabsProps} ref={forwardedRef} />\n    </TabsProvider>\n  );\n}) as TabsPrimitive;\n\nTabs.displayName = TABS_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsList\n * -----------------------------------------------------------------------------------------------*/\n\nconst TAB_LIST_NAME = 'TabsList';\nconst TAB_LIST_DEFAULT_TAG = 'div';\n\ntype TabsListOwnProps = Omit<\n  Polymorphic.OwnProps<typeof RovingFocusGroup>,\n  | 'orientation'\n  | 'currentTabStopId'\n  | 'defaultCurrentTabStopId'\n  | 'onCurrentTabStopIdChange'\n  | 'onEntryFocus'\n>;\ntype TabsListPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TAB_LIST_DEFAULT_TAG,\n  TabsListOwnProps\n>;\n\nconst TabsList = React.forwardRef((props, forwardedRef) => {\n  const { as = TAB_LIST_DEFAULT_TAG, loop = true, ...otherProps } = props;\n  const context = useTabsContext(TAB_LIST_NAME);\n\n  return (\n    <RovingFocusGroup\n      role=\"tablist\"\n      orientation={context.orientation}\n      dir={context.dir}\n      loop={loop}\n      {...otherProps}\n      as={as}\n      ref={forwardedRef}\n    />\n  );\n}) as TabsListPrimitive;\n\nTabsList.displayName = TAB_LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TabsTrigger';\nconst TRIGGER_DEFAULT_TAG = 'div';\n\ntype TabsTriggerOwnProps = Polymorphic.Merge<\n  Omit<Polymorphic.OwnProps<typeof RovingFocusItem>, 'focusable' | 'active'>,\n  {\n    value: string;\n    disabled?: boolean;\n  }\n>;\n\ntype TabsTriggerPrimitive = Polymorphic.ForwardRefComponent<\n  typeof TRIGGER_DEFAULT_TAG,\n  TabsTriggerOwnProps\n>;\n\nconst TabsTrigger = React.forwardRef((props, forwardedRef) => {\n  const { as = TRIGGER_DEFAULT_TAG, value, disabled = false, ...triggerProps } = props;\n  const context = useTabsContext(TRIGGER_NAME);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const isSelected = value === context.value;\n  const handleTabChange = useCallbackRef(() => context.onValueChange(value));\n\n  return (\n    <RovingFocusItem\n      role=\"tab\"\n      aria-selected={isSelected}\n      aria-controls={contentId}\n      aria-disabled={disabled || undefined}\n      data-state={isSelected ? 'active' : 'inactive'}\n      data-disabled={disabled ? '' : undefined}\n      id={triggerId}\n      {...triggerProps}\n      focusable={!disabled}\n      active={isSelected}\n      as={as}\n      ref={forwardedRef}\n      onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n        if (!disabled && (event.key === ' ' || event.key === 'Enter')) {\n          handleTabChange();\n        }\n      })}\n      onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n        // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n        // but not when the control key is pressed (avoiding MacOS right click)\n        if (!disabled && event.button === 0 && event.ctrlKey === false) {\n          handleTabChange();\n        }\n      })}\n      onFocus={composeEventHandlers(props.onFocus, () => {\n        // handle \"automatic\" activation if necessary\n        // ie. activate tab following focus\n        const isAutomaticActivation = context.activationMode !== 'manual';\n        if (!isSelected && !disabled && isAutomaticActivation) {\n          handleTabChange();\n        }\n      })}\n    />\n  );\n}) as TabsTriggerPrimitive;\n\nTabsTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TabsContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TabsContent';\n\ntype TabsContentPropsOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  { value: string }\n>;\ntype TabsContentPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof Primitive>,\n  TabsContentPropsOwnProps\n>;\n\nconst TabsContent = React.forwardRef((props, forwardedRef) => {\n  const { value, ...contentProps } = props;\n  const context = useTabsContext(CONTENT_NAME);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const isSelected = value === context.value;\n\n  return (\n    <Primitive\n      data-state={isSelected ? 'active' : 'inactive'}\n      data-orientation={context.orientation}\n      role=\"tabpanel\"\n      aria-labelledby={triggerId}\n      hidden={!isSelected}\n      id={contentId}\n      tabIndex={0}\n      {...contentProps}\n      ref={forwardedRef}\n    />\n  );\n}) as TabsContentPrimitive;\n\nTabsContent.displayName = CONTENT_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nconst Root = Tabs;\nconst List = TabsList;\nconst Trigger = TabsTrigger;\nconst Content = TabsContent;\n\nexport {\n  Tabs,\n  TabsList,\n  TabsTrigger,\n  TabsContent,\n  //\n  Root,\n  List,\n  Trigger,\n  Content,\n};\nexport type { TabsPrimitive, TabsListPrimitive, TabsTriggerPrimitive, TabsContentPrimitive };\n"],
  "mappings": "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",
  "names": []
}
