{"mappings":"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","sources":["./packages/react/dismissable-layer/src/DismissableLayer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useBodyPointerEvents } from '@radix-ui/react-use-body-pointer-events';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\nimport type * as Polymorphic from '@radix-ui/react-polymorphic';\n\n// We need to compute the total count of layers AND a running count of all layers\n// in order to find which layer is the deepest one.\n// This is use to only dismiss the deepest layer when using the escape key\n// because we bind the key listener to document so cannot take advantage of event.stopPropagation()\nconst [TotalLayerCountProvider, useTotalLayerCount] = createTotalLayerCount();\nconst [RunningLayerCountProvider, usePreviousRunningLayerCount] = createRunningLayerCount();\n\n// We need to compute the total count of layers which set `disableOutsidePointerEvents` to `true` AND\n// a running count of all the layers which set `disableOutsidePointerEvents` to `true` in order to determine\n// which layers should be dismissed when interacting outside.\n// (ie. all layers that do not have a child layer which sets `disableOutsidePointerEvents` to `true`)\nconst [\n  TotalLayerCountWithDisabledOutsidePointerEventsProvider,\n  useTotalLayerCountWithDisabledOutsidePointerEvents,\n] = createTotalLayerCount('TotalLayerCountWithDisabledOutsidePointerEventsProvider');\nconst [\n  RunningLayerCountWithDisabledOutsidePointerEventsProvider,\n  usePreviousRunningLayerCountWithDisabledOutsidePointerEvents,\n] = createRunningLayerCount('RunningLayerCountWithDisabledOutsidePointerEventsProvider');\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\n\ntype DismissableLayerPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof DismissableLayerImpl>,\n  Polymorphic.OwnProps<typeof DismissableLayerImpl>\n>;\n\nconst DismissableLayer = React.forwardRef((props, forwardedRef) => {\n  const runningLayerCount = usePreviousRunningLayerCount();\n  const isRootLayer = runningLayerCount === 0;\n  const layer = <DismissableLayerImpl {...props} ref={forwardedRef} />;\n\n  // if it's the root layer, we wrap it with our necessary root providers\n  // (effectively we wrap the whole tree of nested layers)\n  return isRootLayer ? (\n    <TotalLayerCountProvider>\n      <TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n        {layer}\n      </TotalLayerCountWithDisabledOutsidePointerEventsProvider>\n    </TotalLayerCountProvider>\n  ) : (\n    layer\n  );\n}) as DismissableLayerPrimitive;\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\ntype DismissableLayerImplOwnProps = Polymorphic.Merge<\n  Polymorphic.OwnProps<typeof Primitive>,\n  {\n    /**\n     * When `true`, hover/focus/click interactions will be disabled on elements outside\n     * the `DismissableLayer`. Users will need to click twice on outside elements to\n     * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n     */\n    disableOutsidePointerEvents?: boolean;\n\n    /**\n     * Event handler called when the escape key is down.\n     * Can be prevented.\n     */\n    onEscapeKeyDown?: (event: KeyboardEvent) => void;\n\n    /**\n     * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n     * Can be prevented.\n     */\n    onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n\n    /**\n     * Event handler called when the focus moves outside of the `DismissableLayer`.\n     * Can be prevented.\n     */\n    onFocusOutside?: (event: FocusOutsideEvent) => void;\n\n    /**\n     * Event handler called when an interaction happens outside the `DismissableLayer`.\n     * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n     * Can be prevented.\n     */\n    onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n\n    /** Callback called when the `DismissableLayer` should be dismissed */\n    onDismiss?: () => void;\n  }\n>;\n\ntype DismissableLayerImplPrimitive = Polymorphic.ForwardRefComponent<\n  Polymorphic.IntrinsicElement<typeof Primitive>,\n  DismissableLayerImplOwnProps\n>;\n\nconst DismissableLayerImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    ...layerProps\n  } = props;\n\n  const totalLayerCount = useTotalLayerCount();\n  const prevRunningLayerCount = usePreviousRunningLayerCount();\n  const runningLayerCount = prevRunningLayerCount + 1;\n  const isDeepestLayer = runningLayerCount === totalLayerCount;\n\n  const totalLayerCountWithDisabledOutsidePointerEvents = useTotalLayerCountWithDisabledOutsidePointerEvents(\n    disableOutsidePointerEvents\n  );\n  const prevRunningLayerCountWithDisabledOutsidePointerEvents = usePreviousRunningLayerCountWithDisabledOutsidePointerEvents();\n  const runningLayerCountWithDisabledOutsidePointerEvents =\n    prevRunningLayerCountWithDisabledOutsidePointerEvents + (disableOutsidePointerEvents ? 1 : 0);\n  const containsChildLayerWithDisabledOutsidePointerEvents =\n    runningLayerCountWithDisabledOutsidePointerEvents <\n    totalLayerCountWithDisabledOutsidePointerEvents;\n\n  // Disable pointer-events on `document.body` when at least one layer is disabling outside pointer events\n  useBodyPointerEvents({ disabled: disableOutsidePointerEvents });\n\n  // Dismiss on escape\n  useEscapeKeydown((event) => {\n    // Only dismiss if it's the deepest layer. his is effectively mimicking\n    // event.stopPropagation from the layer with disabled outside pointer events.\n    if (isDeepestLayer) {\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on pointer down outside\n  const { onPointerDownCapture: handlePointerDownCapture } = usePointerDownOutside((event) => {\n    // Only dismiss if there's no deeper layer which disabled pointer events outside itself\n    if (!containsChildLayerWithDisabledOutsidePointerEvents) {\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  });\n\n  // Dismiss on focus outside\n  const { onBlurCapture: handleBlurCapture, onFocusCapture: handleFocusCapture } = useFocusOutside(\n    (event) => {\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) {\n        onDismiss?.();\n      }\n    }\n  );\n\n  // If we have disabled pointer events on body, we need to reset `pointerEvents: 'auto'`\n  // on some layers. This depends on which layers set `disableOutsidePointerEvents` to `true`.\n  //\n  // NOTE: it's important we set it on ALL layers that need it as we cannot simply\n  // set it on the deepest layer which sets `disableOutsidePointerEvents` to `true` and rely\n  // on inheritence. This is because layers may be rendered in different portals where\n  // inheritence wouldn't apply, so we need to set it explicity on its children too.\n  const isBodyPointerEventsDisabled = totalLayerCountWithDisabledOutsidePointerEvents > 0;\n  const shouldReEnablePointerEvents =\n    isBodyPointerEventsDisabled && !containsChildLayerWithDisabledOutsidePointerEvents;\n\n  return (\n    <RunningLayerCountProvider runningCount={runningLayerCount}>\n      <RunningLayerCountWithDisabledOutsidePointerEventsProvider\n        runningCount={runningLayerCountWithDisabledOutsidePointerEvents}\n      >\n        <Primitive\n          {...layerProps}\n          ref={forwardedRef}\n          style={{\n            pointerEvents: shouldReEnablePointerEvents ? 'auto' : undefined,\n            ...layerProps.style,\n          }}\n          onPointerDownCapture={composeEventHandlers(\n            props.onPointerDownCapture,\n            handlePointerDownCapture\n          )}\n          onBlurCapture={composeEventHandlers(props.onBlurCapture, handleBlurCapture)}\n          onFocusCapture={composeEventHandlers(props.onFocusCapture, handleFocusCapture)}\n        />\n      </RunningLayerCountWithDisabledOutsidePointerEventsProvider>\n    </RunningLayerCountProvider>\n  );\n}) as DismissableLayerImplPrimitive;\n\n/* -------------------------------------------------------------------------------------------------\n * Utility hooks\n * -----------------------------------------------------------------------------------------------*/\n\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Sets up `pointerdown` listener which listens for events outside a react subtree.\n *\n * We use `pointerdown` rather than `pointerup` to mimic layer dismissing behaviour\n * present in OS which usually happens on `pointerdown`.\n *\n * Returns props to pass to the node we want to check for outside events.\n */\n\nfunction usePointerDownOutside(onPointerDownOutside?: (event: PointerDownOutsideEvent) => void) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      const target = event.target;\n      if (target && !isPointerInsideReactTreeRef.current) {\n        const pointerDownOutsideEvent: PointerDownOutsideEvent = new CustomEvent(\n          POINTER_DOWN_OUTSIDE,\n          { bubbles: false, cancelable: true, detail: { originalEvent: event } }\n        );\n        target.addEventListener(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, { once: true });\n        target.dispatchEvent(pointerDownOutsideEvent);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      document.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      document.removeEventListener('pointerdown', handlePointerDown);\n    };\n  }, [handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\n\nfunction useFocusOutside(onFocusOutside?: (event: FocusOutsideEvent) => void) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      const target = event.target;\n      if (target && !isFocusInsideReactTreeRef.current) {\n        const focusOutsideEvent: FocusOutsideEvent = new CustomEvent(FOCUS_OUTSIDE, {\n          bubbles: false,\n          cancelable: true,\n          detail: { originalEvent: event },\n        });\n        target.addEventListener(FOCUS_OUTSIDE, handleFocusOutside, { once: true });\n        target.dispatchEvent(focusOutsideEvent);\n      }\n    };\n    document.addEventListener('focusin', handleFocus);\n    return () => document.removeEventListener('focusin', handleFocus);\n  }, [handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\n/* -------------------------------------------------------------------------------------------------\n * Layer counting utilities\n * -----------------------------------------------------------------------------------------------*/\n\nfunction createTotalLayerCount(displayName?: string) {\n  const TotalLayerCountContext = React.createContext<{\n    total: number;\n    setTotal: React.Dispatch<React.SetStateAction<number>>;\n  }>({ total: 0, setTotal: () => {} });\n\n  const TotalLayerCountProvider: React.FC = ({ children }) => {\n    const [total, setTotal] = React.useState(0);\n    const context = React.useMemo(() => ({ total, setTotal }), [total, setTotal]);\n    return (\n      <TotalLayerCountContext.Provider value={context}>{children}</TotalLayerCountContext.Provider>\n    );\n  };\n  if (displayName) {\n    TotalLayerCountProvider.displayName = displayName;\n  }\n\n  function useTotalLayerCount(counted = true) {\n    const { total, setTotal } = React.useContext(TotalLayerCountContext);\n\n    React.useLayoutEffect(() => {\n      if (counted) {\n        setTotal((n) => n + 1);\n        return () => setTotal((n) => n - 1);\n      }\n    }, [counted, setTotal]);\n\n    return total;\n  }\n\n  return [TotalLayerCountProvider, useTotalLayerCount] as const;\n}\n\nfunction createRunningLayerCount(displayName?: string) {\n  const RunningLayerCountContext = React.createContext(0);\n\n  const RunningLayerCountProvider: React.FC<{ runningCount: number }> = (props) => {\n    const { children, runningCount } = props;\n    return (\n      <RunningLayerCountContext.Provider value={runningCount}>\n        {children}\n      </RunningLayerCountContext.Provider>\n    );\n  };\n  if (displayName) {\n    RunningLayerCountProvider.displayName = displayName;\n  }\n\n  function usePreviousRunningLayerCount() {\n    return React.useContext(RunningLayerCountContext) || 0;\n  }\n\n  return [RunningLayerCountProvider, usePreviousRunningLayerCount] as const;\n}\n\nconst Root = DismissableLayer;\n\nexport {\n  DismissableLayer,\n  //\n  Root,\n};\n"],"names":["TotalLayerCountProvider","useTotalLayerCount","createTotalLayerCount","RunningLayerCountProvider","usePreviousRunningLayerCount","createRunningLayerCount","TotalLayerCountWithDisabledOutsidePointerEventsProvider","useTotalLayerCountWithDisabledOutsidePointerEvents","RunningLayerCountWithDisabledOutsidePointerEventsProvider","usePreviousRunningLayerCountWithDisabledOutsidePointerEvents","DismissableLayer","React","forwardRef","props","forwardedRef","isRootLayer","layer","_react","createElement","$b3ca5e0c42ec5d7395c8cb24157$var$DismissableLayerImpl","_babelRuntimeHelpersEsmExtends","ref","$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountProvider","$b3ca5e0c42ec5d7395c8cb24157$var$TotalLayerCountWithDisabledOutsidePointerEventsProvider","DismissableLayerImpl","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","totalLayerCount","runningLayerCount","isDeepestLayer","totalLayerCountWithDisabledOutsidePointerEvents","runningLayerCountWithDisabledOutsidePointerEvents","containsChildLayerWithDisabledOutsidePointerEvents","useBodyPointerEvents","disabled","useEscapeKeydown","event","defaultPrevented","onPointerDownCapture","handlePointerDownCapture","handlePointerDownOutside","useCallbackRef","isPointerInsideReactTreeRef","useRef","useEffect","handlePointerDown","target","current","pointerDownOutsideEvent","CustomEvent","bubbles","cancelable","detail","originalEvent","addEventListener","once","dispatchEvent","timerId","window","setTimeout","document","clearTimeout","removeEventListener","usePointerDownOutside","onBlurCapture","handleBlurCapture","onFocusCapture","handleFocusCapture","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","focusOutsideEvent","useFocusOutside","shouldReEnablePointerEvents","$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountProvider","runningCount","$b3ca5e0c42ec5d7395c8cb24157$var$RunningLayerCountWithDisabledOutsidePointerEventsProvider","Primitive","style","pointerEvents","undefined","composeEventHandlers","displayName","TotalLayerCountContext","createContext","total","setTotal","children","useState","context","useMemo","Provider","value","counted","useContext","useLayoutEffect","n","RunningLayerCountContext","Root"],"version":3,"file":"index.module.js.map"}