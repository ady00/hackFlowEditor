{"mappings":"uIASA,SAASA,mBAWP,MAAMC,eAAUC,EAAMC,cAA4B,IAI5CC,EAAgCC,IACpC,MAAMC,SAAEA,GAAaD,EACfE,EAAML,EAAMM,OAA0B,MACtCC,EAAUP,EAAMM,OAAgC,IAAIE,KAAOC,qBACjE,OACEC,EAAAC,cAACZ,EAAQa,SAAT,CAAkBC,MAAOb,EAAMc,SAAQ,KAAA,CAASP,QAAAA,EAASQ,cAAeV,KAAQ,CAACE,KAC9EH,IAeDY,eAAiBhB,EAAMiB,YAAyC,CAACd,EAAOe,KAC5E,MAAMd,SAAEA,GAAaD,EACfgB,EAAUnB,EAAMoB,WAAWrB,GAC3BsB,EAAeC,EAAgBJ,EAAcC,EAAQJ,4BAC3D,OAAOL,EAAAC,cAACY,EAAD,CAAMlB,IAAKgB,GAAejB,MAU7BoB,EAAiB,6BAIjBC,eAAqBzB,EAAMiB,YAC/B,CAACd,EAAOe,KACN,MAAMd,SAAEA,KAAasB,GAAavB,EAC5BE,EAAML,EAAMM,OAAoB,MAChCe,EAAeC,EAAgBJ,EAAcb,GAC7Cc,EAAUnB,EAAMoB,WAAWrB,GAOjC,OALAC,EAAM2B,WAAU,KACdR,EAAQZ,QAAQqB,IAAIvB,EAAK,CAAEA,IAAAA,KAAUqB,IAC9B,KAAWP,EAAQZ,QAAQsB,OAAOxB,oBAIzCK,EAAAC,cAACY,EAAD,CAAYO,CAACN,GAAiB,GAAMnB,IAAKgB,GACtCjB,MA4BT,MAAO,CAACF,EAAoBc,EAAgBS,EAhB5C,WACE,MAAMN,EAAUnB,EAAMoB,WAAWrB,GACjC,MAAO,CACLgC,WACE,MAAMC,EAAeC,MAAMC,KACzBf,EAAQJ,cAAcN,QAAS0B,iBAAkB,IAAGX,OAMtD,OAJcS,MAAMC,KAAKf,EAAQZ,QAAQ6B,UACdC,MACzB,CAACC,EAAGC,IAAMP,EAAaQ,QAAQF,EAAEjC,IAAII,SAAYuB,EAAaQ,QAAQD,EAAElC,IAAII","sources":["./packages/react/collection/src/Collection.tsx"],"sourcesContent":["import React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Slot } from '@radix-ui/react-slot';\n\n// We have resorted to returning slots directly rather than exposing primitives that can then\n// be slotted like `<CollectionItem as={Slot}>â€¦</CollectionItem>`.\n// This is because we encountered issues with generic types that cannot be statically analysed\n// due to creating them dynamically via createCollection.\n\nfunction createCollection<ItemElement extends HTMLElement, ItemData>() {\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionProvider\n   * ---------------------------------------------------------------------------------------------*/\n\n  type CollectionElement = HTMLElement;\n\n  type ContextValue = {\n    collectionRef: React.RefObject<CollectionElement>;\n    itemMap: Map<React.RefObject<ItemElement>, { ref: React.RefObject<ItemElement> } & ItemData>;\n  };\n  const Context = React.createContext<ContextValue>({} as any);\n\n  const PROVIDER_NAME = 'CollectionProvider';\n\n  const CollectionProvider: React.FC = (props) => {\n    const { children } = props;\n    const ref = React.useRef<CollectionElement>(null);\n    const itemMap = React.useRef<ContextValue['itemMap']>(new Map()).current;\n    return (\n      <Context.Provider value={React.useMemo(() => ({ itemMap, collectionRef: ref }), [itemMap])}>\n        {children}\n      </Context.Provider>\n    );\n  };\n\n  CollectionProvider.displayName = PROVIDER_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionSlot\n   * ---------------------------------------------------------------------------------------------*/\n\n  const COLLECTION_SLOT_NAME = 'CollectionSlot';\n\n  type SlotProps = React.ComponentProps<typeof Slot>;\n\n  const CollectionSlot = React.forwardRef<CollectionElement, SlotProps>((props, forwardedRef) => {\n    const { children } = props;\n    const context = React.useContext(Context);\n    const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);\n    return <Slot ref={composedRefs}>{children}</Slot>;\n  });\n\n  CollectionSlot.displayName = COLLECTION_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * CollectionItem\n   * ---------------------------------------------------------------------------------------------*/\n\n  const ITEM_SLOT_NAME = 'CollectionItemSlot';\n  const ITEM_DATA_ATTR = 'data-radix-collection-item';\n\n  type CollectionItemSlotProps = { children: React.ReactNode } & ItemData;\n\n  const CollectionItemSlot = React.forwardRef<ItemElement, CollectionItemSlotProps>(\n    (props, forwardedRef) => {\n      const { children, ...itemData } = props;\n      const ref = React.useRef<ItemElement>(null);\n      const composedRefs = useComposedRefs(forwardedRef, ref);\n      const context = React.useContext(Context);\n\n      React.useEffect(() => {\n        context.itemMap.set(ref, { ref, ...((itemData as unknown) as ItemData) });\n        return () => void context.itemMap.delete(ref);\n      });\n\n      return (\n        <Slot {...{ [ITEM_DATA_ATTR]: '' }} ref={composedRefs}>\n          {children}\n        </Slot>\n      );\n    }\n  );\n\n  CollectionItemSlot.displayName = ITEM_SLOT_NAME;\n\n  /* -----------------------------------------------------------------------------------------------\n   * useCollection\n   * ---------------------------------------------------------------------------------------------*/\n\n  function useCollection() {\n    const context = React.useContext(Context);\n    return {\n      getItems() {\n        const orderedNodes = Array.from(\n          context.collectionRef.current!.querySelectorAll(`[${ITEM_DATA_ATTR}]`)\n        );\n        const items = Array.from(context.itemMap.values());\n        const orderedItems = items.sort(\n          (a, b) => orderedNodes.indexOf(a.ref.current!) - orderedNodes.indexOf(b.ref.current!)\n        );\n        return orderedItems;\n      },\n    };\n  }\n\n  return [CollectionProvider, CollectionSlot, CollectionItemSlot, useCollection] as const;\n}\n\nexport { createCollection };\n"],"names":["createCollection","Context","React","createContext","CollectionProvider","props","children","ref","useRef","itemMap","Map","current","_react","createElement","Provider","value","useMemo","collectionRef","CollectionSlot","forwardRef","forwardedRef","context","useContext","composedRefs","useComposedRefs","Slot","ITEM_DATA_ATTR","CollectionItemSlot","itemData","useEffect","set","delete","[object Object]","getItems","orderedNodes","Array","from","querySelectorAll","values","sort","a","b","indexOf"],"version":3,"file":"index.module.js.map"}